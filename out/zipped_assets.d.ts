/// <reference types="node" />
declare type zipEntryName = string;
declare type subDirectory = "cn_official" | "cn_mod" | "cn_output";
export declare class zippedAssets {
    private static readonly assetJsonNames;
    private static readonly FHSigature;
    private static readonly CDFHSigature;
    private static readonly EOCDSigature;
    private static readonly cnOffcialZippedAssetsDir;
    private readonly assetToZipMap;
    private readonly fileHandleMap;
    private static readonly fileExtRegEx;
    private static readonly contentTypeMap;
    static readonly defMimeType = "application/octet-stream";
    private static readonly CNLegacyRootDir;
    private static readonly CNLegacyPathPrefix;
    private static readonly CNLegacyAssetVer;
    private static readonly CNLegacyAssetJsonDir;
    private static readonly CNLegacy404Set;
    static CNLegacyIsKnown404(pathInUrl: string): boolean;
    private static readonly chunkSize;
    private constructor();
    static init(): Promise<zippedAssets>;
    private static registerZips;
    private static readonly mapVerMagic;
    private static serializeTempMap;
    private static deserializeTempMap;
    private static convertCNLegacy;
    private static isCNLegacyConversionUnfinished;
    private static markCNLegacyConversionFinished;
    readonly integrityCheckStatus: integrityCheckStatus;
    checkIntegrity(subDirectory?: subDirectory): Promise<boolean>;
    private _checkIntegrity;
    private static crc32;
    private static parseZip;
    private static readFileHeader;
    private static newFileHeader;
    private static modifyFileHeader;
    private static parseCDFH;
    private static newCDFH;
    private static modifyCDFH;
    private static findEOCD;
    private static newEOCD;
    private static checkIsDir;
    private static checkIsFile;
    private static checkFileFinished;
    private static markFileFinished;
    getPathInZip(pathInUrl: string): string | undefined;
    readFileAsync(pathInUrl: string, crc32?: boolean | number): Promise<Buffer | undefined>;
    static getContentType(pathInUrl: string): string;
    private extract;
}
declare class integrityCheckStatus {
    private md5Map;
    private webResFileSet;
    private extraSet;
    private _totalCount?;
    get totalCount(): number;
    private readonly okaySet;
    private readonly missingSet;
    private readonly md5MismatchSet;
    private readonly crc32MismatchSet;
    addPassed(pathInZip: zipEntryName): void;
    addMissing(pathInZip: zipEntryName): void;
    addMismatch(pathInZip: zipEntryName, checksumType: "md5" | "crc32"): void;
    private _passedCount?;
    get passedCount(): number;
    private _missingCount?;
    get missingCount(): number;
    private _md5MismatchCount?;
    get md5MismatchCount(): number;
    private _crc32MismatchCount?;
    get crc32MismatchCount(): number;
    get failedCount(): number;
    get doneCount(): number;
    get remainingCount(): number;
    get isAllPassed(): boolean;
    isFilePassed(pathInZip: zipEntryName): boolean;
    get statusString(): string;
    clear(keepCounts?: boolean): void;
    init(md5Map: Map<zipEntryName, string>, webResFileSet: Set<zipEntryName>, extraSet: Set<zipEntryName>): void;
    private readonly pendingRequestSet;
    get isRunning(): boolean;
    getPendingResult(): Promise<boolean>;
    notifyDone(): void;
    notifyError(e?: any): void;
}
export {};
